#!/usr/bin/env python3

from sys import argv, stderr, stdout
from os.path import basename, isdir, join, splitext
import re
from glob import glob


def snake_case_to_camel_case(name):
	return ''.join(map(lambda x: x[0].upper() + x[1:].lower(), name.split('_')))

_clean_path_re = re.compile(r'(?:./)?(?P<path>.*?)(?:/)?')
def clean_path_segment(seg):
	match = _clean_path_re.fullmatch(seg)
	return match.group('path')

def lair_join(*args):
	return '/'.join(filter(bool, map(clean_path_segment, args)))

def write_file(out, logic_path, real_path):
	file = open(real_path, 'rb')

	out.write('\t{\n\t\tstatic const char* data =\n')

	block_size = 16
	size = 0
	finished = False
	for line in iter(lambda: file.read(block_size), b''):
		out.write('\t\t\t"')
		size += len(line)
		for b in line:
			out.write('\\x')
			out.write(format(b, '02x'))
		out.write('"\n')
	out.write('\t\t;\n')
	file.close()

	out.write('\t\tfs.addFile(lair::Path("')
	out.write(logic_path)
	out.write('"), ')
	out.write(format(size, 'd'))
	out.write(', (const lair::Byte*)data);\n\t}\n')

def write_file_or_dir(out, logic_path, real_path):
	if isdir(real_path):
		for file in glob(join(real_path, '*')):
			logic = lair_join(logic_path, basename(file))
			write_file_or_dir(out, logic, file)
	else:
		write_file(out, logic_path, real_path)

def write_files(out, fn_name, files, namespace = None):
	out.write("""/*
 *  This file is auto-generated by resource.py.
 */

#include <lair/core/lair.h>

#include <lair/fs/memory_file_system.h>

""")

	if namespace:
		out.write('namespace ')
		out.write(namespace)
		out.write(' {\n\n')

	out.write('void ')
	out.write(fn_name)
	out.write('(lair::MemoryFileSystem& fs) {\n')

	for logic_path, real_path in files:
		write_file_or_dir(out, logic_path, real_path)

	out.write('}\n')

	if namespace:
		out.write('\n}\n')


def usage(message=None, file=stderr, status=1):
	if message:
		file.write(message)
	file.write("""{argv[0]} [<options>] [-r <logic-path> <real-path> ...]
Create a c++ file containing the data from resources-files.

The output file contains a single function that register a set of memory buffers
to a MemoryFileSystem. By default the function is named 'registerSomething'
where 'Something' is the name of the output file without extension, or
'registerResource' if -o is not specified.

Opitons:
  -f <function-name>  Call the register function <function-name>.
  -h --help           Display this message and exit.
  -n <namespace>      Encapsulate the code in the namespace <namespace>.
  -o <output-file>    Write the output to <output-file> instead of stdout.
  -p <prefix-path>    Precede the paths of the files by <prefix-path>.
  -r <logic-path> <real-path>
                      Add the file pointed by <real-path> as a resource
                      registered under the name <logic-path>.
""".format_map(globals()))
	if status is not None:
		exit(status)

if __name__ == '__main__':
	resource       = []
	out_file       = None
	function_name  = None
	prefix         = None
	namespace      = None

	argit = iter(argv[1:])
	for arg in argit:
		if arg == '-f':
			if function_name is not None:
				usage("Error: option -f can not be specified multiple times.")
			try:
				function_name = next(argit)
			except StopIteration:
				usage("Error: option -f requires an argument.")
		elif arg == '-h' or arg == '--help':
			usage(None, stdout, 0)
		elif arg == '-n':
			if namespace is not None:
				usage("Error: option -n can not be specified multiple times.")
			try:
				namespace = next(argit)
			except StopIteration:
				usage("Error: option -n requires an argument.")
		elif arg == '-o':
			if out_file is not None:
				usage("Error: option -o can not be specified multiple times.")
			try:
				out_file = next(argit)
			except StopIteration:
				usage("Error: option -o requires an argument.")
		elif arg == '-p':
			if prefix is not None:
				usage("Error: option -p can not be specified multiple times.")
			try:
				prefix = next(argit)
			except StopIteration:
				usage("Error: option -p requires an argument.")
		elif arg == '-r':
			try:
				logic = next(argit)
				real  = next(argit)
			except StopIteration:
				usage("Error: option -r requires two argument.")
			resource.append((logic, real))
		else:
			usage("Unrecognized argument " + arg)

	if function_name is None:
		if out_file is None:
			function_name = 'registerResource'
		else:
			function_name = 'register' + snake_case_to_camel_case(splitext(basename(out_file))[0])

	out = stdout
	if out_file:
		out = open(out_file, 'w')

	def create_path_pair(filename):
		if prefix:
			return '{}/{}'.format(prefix, filename), filename
		return filename, filename

	write_files(out, function_name, resource, namespace = namespace)
	out.close()
